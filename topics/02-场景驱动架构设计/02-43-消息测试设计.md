# 2.43 消息测试设计

## 目录

- [2.43 消息测试设计](#243-消息测试设计)
  - [目录](#目录)
  - [2.43.1 测试场景](#2431-测试场景)
    - [常见场景](#常见场景)
  - [2.43.2 Kafka测试](#2432-kafka测试)
    - [测试实现](#测试实现)
  - [2.43.3 NATS测试](#2433-nats测试)
    - [测试实现](#测试实现-1)
  - [2.43.4 RabbitMQ测试](#2434-rabbitmq测试)
    - [测试实现](#测试实现-2)
  - [2.43.5 测试最佳实践](#2435-测试最佳实践)
    - [设计建议](#设计建议)

---

## 2.43.1 测试场景

### 常见场景

1. **功能测试**
   - 消息发送测试
   - 消息消费测试
   - 消息路由测试

2. **性能测试**
   - 吞吐量测试
   - 延迟测试
   - 压力测试

3. **可靠性测试**
   - 故障注入测试
   - 容错测试
   - 恢复测试

---

## 2.43.2 Kafka测试

### 测试实现

```java
// 功能测试
@Test
public void testMessageSend() {
    ProducerRecord<String, String> record =
        new ProducerRecord<>("orders", "key", "value");
    Future<RecordMetadata> future = producer.send(record);
    RecordMetadata metadata = future.get();
    assertNotNull(metadata);
}

@Test
public void testMessageConsume() {
    ConsumerRecords<String, String> records = consumer.poll(Duration.ofSeconds(1));
    assertEquals(1, records.count());
}

// 性能测试
@Test
public void testThroughput() {
    long startTime = System.currentTimeMillis();
    for (int i = 0; i < 10000; i++) {
        producer.send(new ProducerRecord<>("orders", "key" + i, "value" + i));
    }
    long endTime = System.currentTimeMillis();
    double throughput = 10000.0 / ((endTime - startTime) / 1000.0);
    assertTrue(throughput > 1000);  // 每秒1000条
}

// 可靠性测试
@Test
public void testFaultTolerance() {
    // 模拟Broker故障
    killBroker(1);
    // 验证消息仍能发送
    producer.send(new ProducerRecord<>("orders", "key", "value"));
}
```

---

## 2.43.3 NATS测试

### 测试实现

```go
// 功能测试
func TestMessagePublish(t *testing.T) {
    nc, _ := nats.Connect("nats://localhost:4222")
    defer nc.Close()

    err := nc.Publish("orders", []byte("test message"))
    assert.NoError(t, err)
}

func TestMessageSubscribe(t *testing.T) {
    nc, _ := nats.Connect("nats://localhost:4222")
    defer nc.Close()

    sub, _ := nc.Subscribe("orders", func(msg *nats.Msg) {
        assert.Equal(t, "test message", string(msg.Data))
    })
    defer sub.Unsubscribe()
}

// 性能测试
func TestThroughput(t *testing.T) {
    startTime := time.Now()
    for i := 0; i < 10000; i++ {
        nc.Publish("orders", []byte(fmt.Sprintf("message %d", i)))
    }
    duration := time.Since(startTime)
    throughput := float64(10000) / duration.Seconds()
    assert.True(t, throughput > 1000)  // 每秒1000条
}
```

---

## 2.43.4 RabbitMQ测试

### 测试实现

```python
# 功能测试
def test_message_publish():
    channel.basic_publish(
        exchange='orders',
        routing_key='',
        body='test message'
    )
    assert True

def test_message_consume():
    def callback(ch, method, properties, body):
        assert body == b'test message'
        ch.basic_ack(delivery_tag=method.delivery_tag)

    channel.basic_consume(queue='orders', on_message_callback=callback)

# 性能测试
def test_throughput():
    start_time = time.time()
    for i in range(10000):
        channel.basic_publish(
            exchange='orders',
            routing_key='',
            body=f'message {i}'
        )
    duration = time.time() - start_time
    throughput = 10000 / duration
    assert throughput > 1000  # 每秒1000条
```

---

## 2.43.5 测试最佳实践

### 设计建议

1. **功能测试**
   - 单元测试
   - 集成测试
   - 端到端测试

2. **性能测试**
   - 基准测试
   - 压力测试
   - 负载测试

3. **可靠性测试**
   - 故障注入
   - 容错测试
   - 恢复测试

---

**最后更新**: 2025-12-31
