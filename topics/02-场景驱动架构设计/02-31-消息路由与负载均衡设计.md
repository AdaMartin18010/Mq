# 2.31 消息路由与负载均衡设计

## 目录

- [2.31 消息路由与负载均衡设计](#231-消息路由与负载均衡设计)
  - [目录](#目录)
  - [2.31.1 路由场景](#2311-路由场景)
    - [常见场景](#常见场景)
  - [2.31.2 Kafka路由](#2312-kafka路由)
    - [路由实现](#路由实现)
  - [2.31.3 NATS路由](#2313-nats路由)
    - [路由实现](#路由实现-1)
  - [2.31.4 RabbitMQ路由](#2314-rabbitmq路由)
    - [路由实现](#路由实现-2)
  - [2.31.5 路由最佳实践](#2315-路由最佳实践)
    - [设计建议](#设计建议)

---

## 2.31.1 路由场景

### 常见场景

1. **消息路由**
   - 基于内容路由
   - 基于规则路由
   - 动态路由

2. **负载均衡**
   - 消息分发
   - 消费者均衡
   - 资源均衡

3. **路由策略**
   - 轮询路由
   - 哈希路由
   - 优先级路由

---

## 2.31.2 Kafka路由

### 路由实现

```java
// 基于Key的路由（分区路由）
ProducerRecord<String, String> record = new ProducerRecord<>(
    "orders",
    orderId,  // Key用于路由到特定分区
    orderJson
);

// 自定义分区器实现路由
public class OrderPartitioner implements Partitioner {
    @Override
    public int partition(String topic, Object key, byte[] keyBytes,
                        Object value, byte[] valueBytes, Cluster cluster) {
        // 根据业务规则路由
        if (key.toString().startsWith("VIP")) {
            return 0;  // VIP订单路由到分区0
        }
        return Math.abs(key.hashCode()) % cluster.partitionCountForTopic(topic);
    }
}
```

---

## 2.31.3 NATS路由

### 路由实现

```go
// Subject路由
subject := fmt.Sprintf("orders.%s.%s", region, priority)
nc.Publish(subject, data)

// 队列组负载均衡
nc.QueueSubscribe("orders.*", "workers", func(msg *nats.Msg) {
    // 自动负载均衡到多个消费者
    process(msg)
})
```

---

## 2.31.4 RabbitMQ路由

### 路由实现

```python
# Topic Exchange路由
channel.exchange_declare(exchange='orders', exchange_type='topic')

# 基于路由键路由
channel.basic_publish(
    exchange='orders',
    routing_key='order.created.vip',  # 路由键
    body=message
)

# 队列绑定路由键
channel.queue_bind(
    exchange='orders',
    queue='vip-orders',
    routing_key='order.created.vip'
)
```

---

## 2.31.5 路由最佳实践

### 设计建议

1. **路由设计**
   - 明确路由规则
   - 合理路由键选择
   - 负载均衡考虑

2. **性能优化**
   - 路由计算优化
   - 缓存路由结果
   - 减少路由开销

3. **运维管理**
   - 路由监控
   - 路由规则管理
   - 动态路由调整

---

**最后更新**: 2025-12-31
