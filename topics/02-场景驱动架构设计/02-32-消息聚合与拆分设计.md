# 2.32 消息聚合与拆分设计

## 目录

- [2.32 消息聚合与拆分设计](#232-消息聚合与拆分设计)
  - [目录](#目录)
  - [2.32.1 聚合拆分场景](#2321-聚合拆分场景)
    - [常见场景](#常见场景)
  - [2.32.2 Kafka聚合拆分](#2322-kafka聚合拆分)
    - [聚合实现](#聚合实现)
    - [拆分实现](#拆分实现)
  - [2.32.3 NATS聚合拆分](#2323-nats聚合拆分)
    - [聚合实现](#聚合实现-1)
  - [2.32.4 RabbitMQ聚合拆分](#2324-rabbitmq聚合拆分)
    - [聚合实现](#聚合实现-2)
  - [2.32.5 聚合拆分最佳实践](#2325-聚合拆分最佳实践)
    - [设计建议](#设计建议)

---

## 2.32.1 聚合拆分场景

### 常见场景

1. **消息聚合**
   - 批量处理
   - 减少网络开销
   - 提高吞吐量

2. **消息拆分**
   - 大消息拆分
   - 批量拆分
   - 提高处理效率

3. **聚合拆分策略**
   - 时间窗口聚合
   - 数量阈值聚合
   - 大小阈值拆分

---

## 2.32.2 Kafka聚合拆分

### 聚合实现

```java
// Producer批处理聚合
Properties props = new Properties();
props.put("batch.size", 16384);  // 批次大小
props.put("linger.ms", 10);      // 等待时间

Producer<String, String> producer = new KafkaProducer<>(props);

// 批量发送（自动聚合）
for (int i = 0; i < 100; i++) {
    producer.send(new ProducerRecord<>("orders", key, value));
}
producer.flush();

// Consumer批量消费（聚合处理）
ConsumerRecords<String, String> records = consumer.poll(Duration.ofMillis(100));
List<Order> orders = new ArrayList<>();
for (ConsumerRecord<String, String> record : records) {
    orders.add(parseOrder(record.value()));
}
batchProcessOrders(orders);
```

### 拆分实现

```java
// 大消息拆分
public List<ProducerRecord<String, String>> splitLargeMessage(
        String topic, String key, String largeMessage, int maxSize) {
    List<ProducerRecord<String, String>> records = new ArrayList<>();
    int offset = 0;
    int partIndex = 0;

    while (offset < largeMessage.length()) {
        int end = Math.min(offset + maxSize, largeMessage.length());
        String chunk = largeMessage.substring(offset, end);

        ProducerRecord<String, String> record = new ProducerRecord<>(
            topic,
            key + "-part-" + partIndex,
            chunk
        );
        records.add(record);

        offset = end;
        partIndex++;
    }

    return records;
}
```

---

## 2.32.3 NATS聚合拆分

### 聚合实现

```go
// 消息聚合
var messages []*nats.Msg
for i := 0; i < 100; i++ {
    msg := &nats.Msg{
        Subject: "orders",
        Data:    []byte(data),
    }
    messages = append(messages, msg)
}

// 批量发送
for _, msg := range messages {
    nc.PublishMsg(msg)
}
nc.Flush()

// 批量订阅处理
var batch []*nats.Msg
nc.Subscribe("orders", func(msg *nats.Msg) {
    batch = append(batch, msg)
    if len(batch) >= 100 {
        processBatch(batch)
        batch = batch[:0]
    }
})
```

---

## 2.32.4 RabbitMQ聚合拆分

### 聚合实现

```python
# 消息聚合
messages = []
for i in range(100):
    messages.append(('orders', '', json.dumps(order)))

# 批量发布
channel.basic_publish_batch(messages)

# 批量消费
batch = []
def process_batch(ch, method, properties, body):
    batch.append(body)
    if len(batch) >= 100:
        process_orders(batch)
        batch.clear()
        ch.basic_ack(method.delivery_tag, multiple=True)

channel.basic_consume(queue='orders', on_message_callback=process_batch)
```

---

## 2.32.5 聚合拆分最佳实践

### 设计建议

1. **聚合设计**
   - 合理批次大小
   - 时间窗口控制
   - 性能vs延迟平衡

2. **拆分设计**
   - 合理拆分大小
   - 拆分标识管理
   - 重组机制

3. **性能优化**
   - 聚合拆分开销
   - 内存使用优化
   - 网络传输优化

---

**最后更新**: 2025-12-31
