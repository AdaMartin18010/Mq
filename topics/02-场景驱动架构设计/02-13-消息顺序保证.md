# 2.13 消息顺序保证

## 目录

- [2.13 消息顺序保证](#213-消息顺序保证)
  - [目录](#目录)
  - [2.13.1 顺序保证级别](#2131-顺序保证级别)
    - [顺序级别](#顺序级别)
  - [2.13.2 Kafka顺序保证](#2132-kafka顺序保证)
    - [分区内顺序](#分区内顺序)
    - [顺序保证策略](#顺序保证策略)
  - [2.13.3 NATS顺序保证](#2133-nats顺序保证)
    - [Core NATS顺序](#core-nats顺序)
    - [JetStream顺序](#jetstream顺序)
  - [2.13.4 RabbitMQ顺序保证](#2134-rabbitmq顺序保证)
    - [单队列顺序](#单队列顺序)
    - [顺序保证限制](#顺序保证限制)
  - [2.13.5 顺序保证最佳实践](#2135-顺序保证最佳实践)
    - [设计建议](#设计建议)

---

## 2.13.1 顺序保证级别

### 顺序级别

1. **全局顺序**
   - 所有消息全局有序
   - 性能最低
   - 适用：严格顺序场景

2. **分区顺序**
   - 同一分区内有序
   - 性能中等
   - 适用：大部分场景

3. **无顺序保证**
   - 不保证顺序
   - 性能最高
   - 适用：顺序无关场景

---

## 2.13.2 Kafka顺序保证

### 分区内顺序

```java
// 单分区Producer（保证顺序）
Properties props = new Properties();
props.put("max.in.flight.requests.per.connection", 1);
props.put("retries", Integer.MAX_VALUE);
props.put("acks", "all");

// 相同Key路由到同一分区
producer.send(new ProducerRecord<>("topic", key, value));
```

### 顺序保证策略

- **单分区**：同一分区内有序
- **单Producer**：max.in.flight.requests=1
- **单Consumer**：单线程消费

---

## 2.13.3 NATS顺序保证

### Core NATS顺序

```go
// Core NATS保证顺序（单连接）
nc.Subscribe("orders", func(msg *nats.Msg) {
    // 消息按接收顺序处理
})
```

### JetStream顺序

```go
// JetStream保证顺序
js.Subscribe("orders", func(msg *nats.Msg) {
    // 按发布顺序处理
}, nats.OrderedConsumer())
```

---

## 2.13.4 RabbitMQ顺序保证

### 单队列顺序

```python
# 单队列单消费者（保证顺序）
channel.queue_declare(queue='orders', durable=True)
channel.basic_qos(prefetch_count=1)  # 一次处理一条
channel.basic_consume(queue='orders', on_message_callback=callback)
```

### 顺序保证限制

- **单队列单消费者**：保证顺序
- **多消费者**：不保证顺序
- **镜像队列**：可能乱序

---

## 2.13.5 顺序保证最佳实践

### 设计建议

1. **业务设计**
   - 避免全局顺序需求
   - 使用分区/分片
   - 业务层补偿

2. **技术实现**
   - 单分区/单队列
   - 单线程消费
   - 幂等处理

3. **性能权衡**
   - 顺序 vs 性能
   - 根据场景选择
   - 监控顺序性

---

**最后更新**: 2025-12-31
