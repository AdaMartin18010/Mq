# 2.17 死信队列设计

## 目录

- [2.17 死信队列设计](#217-死信队列设计)
  - [目录](#目录)
  - [2.17.1 死信队列概念](#2171-死信队列概念)
    - [死信队列作用](#死信队列作用)
  - [2.17.2 Kafka死信队列](#2172-kafka死信队列)
    - [实现方式](#实现方式)
    - [配置建议](#配置建议)
  - [2.17.3 NATS死信队列](#2173-nats死信队列)
    - [JetStream死信](#jetstream死信)
  - [2.17.4 RabbitMQ死信队列](#2174-rabbitmq死信队列)
    - [死信Exchange配置](#死信exchange配置)
  - [2.17.5 死信队列最佳实践](#2175-死信队列最佳实践)
    - [设计建议](#设计建议)

---

## 2.17.1 死信队列概念

### 死信队列作用

1. **错误处理**
   - 收集处理失败的消息
   - 避免消息丢失
   - 便于问题排查

2. **重试管理**
   - 超过重试次数后进入死信队列
   - 避免无限重试
   - 人工介入处理

3. **监控告警**
   - 监控死信队列大小
   - 告警异常情况
   - 及时处理

---

## 2.17.2 Kafka死信队列

### 实现方式

```java
// 创建死信Topic
String dlqTopic = "dlq-" + originalTopic;

// 处理失败后发送到死信队列
try {
    process(record);
    consumer.commitSync();
} catch (Exception e) {
    // 发送到死信队列
    producer.send(new ProducerRecord<>(dlqTopic, record.key(), record.value()));
    consumer.commitSync();
}
```

### 配置建议

- 独立Topic存储死信
- 设置保留策略
- 监控死信数量

---

## 2.17.3 NATS死信队列

### JetStream死信

```go
// 配置死信主题
js.AddStream(&nats.StreamConfig{
    Name: "ORDERS",
    Subjects: []string{"orders.*"},
    MaxDeliver: 3,  // 最大重试次数
})

// 超过重试次数后自动进入死信
js.Subscribe("orders.*", func(msg *nats.Msg) {
    if err := process(msg); err != nil {
        msg.Nak() // 触发重试
    }
}, nats.MaxDeliver(3))
```

---

## 2.17.4 RabbitMQ死信队列

### 死信Exchange配置

```python
# 声明死信Exchange
channel.exchange_declare(exchange='dlx', exchange_type='direct')

# 声明死信队列
channel.queue_declare(queue='dlq', durable=True)

# 绑定死信队列
channel.queue_bind(exchange='dlx', queue='dlq', routing_key='error')

# 主队列配置死信Exchange
channel.queue_declare(
    queue='orders',
    durable=True,
    arguments={
        'x-dead-letter-exchange': 'dlx',
        'x-dead-letter-routing-key': 'error',
        'x-message-ttl': 60000  # 消息TTL
    }
)
```

---

## 2.17.5 死信队列最佳实践

### 设计建议

1. **死信队列设计**
   - 独立队列/Topic
   - 持久化存储
   - 设置保留策略

2. **监控告警**
   - 监控死信数量
   - 设置告警阈值
   - 及时处理

3. **处理流程**
   - 定期检查死信
   - 分析失败原因
   - 修复后重新处理

---

**最后更新**: 2025-12-31
