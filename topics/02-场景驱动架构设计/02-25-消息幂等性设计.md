# 2.25 消息幂等性设计

## 目录

- [2.25 消息幂等性设计](#225-消息幂等性设计)
  - [目录](#目录)
  - [2.25.1 幂等性场景](#2251-幂等性场景)
    - [常见场景](#常见场景)
  - [2.25.2 Kafka幂等性](#2252-kafka幂等性)
    - [Producer幂等性](#producer幂等性)
    - [Consumer幂等性](#consumer幂等性)
  - [2.25.3 NATS幂等性](#2253-nats幂等性)
    - [实现方式](#实现方式)
  - [2.25.4 RabbitMQ幂等性](#2254-rabbitmq幂等性)
    - [实现方式](#实现方式-1)
  - [2.25.5 幂等性最佳实践](#2255-幂等性最佳实践)
    - [设计建议](#设计建议)

---

## 2.25.1 幂等性场景

### 常见场景

1. **重复消息处理**
   - 网络重传
   - 系统重试
   - 故障恢复

2. **业务幂等性**
   - 订单创建
   - 支付处理
   - 状态更新

3. **Exactly-Once语义**
   - 精确一次处理
   - 重复检测
   - 幂等保证

---

## 2.25.2 Kafka幂等性

### Producer幂等性

```java
// 启用幂等性Producer
Properties props = new Properties();
props.put("enable.idempotence", "true");
props.put("acks", "all");
props.put("retries", Integer.MAX_VALUE);

Producer<String, String> producer = new KafkaProducer<>(props);

// 使用事务保证幂等性
producer.initTransactions();
try {
    producer.beginTransaction();
    producer.send(new ProducerRecord<>("orders", key, value));
    producer.commitTransaction();
} catch (Exception e) {
    producer.abortTransaction();
}
```

### Consumer幂等性

```java
// 应用层幂等性检查
Set<String> processedIds = new ConcurrentHashMap<>().keySet();

for (ConsumerRecord<String, String> record : records) {
    String messageId = extractMessageId(record);
    if (processedIds.contains(messageId)) {
        continue;  // 已处理，跳过
    }
    process(record);
    processedIds.add(messageId);
}
```

---

## 2.25.3 NATS幂等性

### 实现方式

```go
// 使用MsgId实现幂等性
js.Publish("orders", data, nats.MsgId("msg-123"))

// Consumer幂等性检查
processedIDs := make(map[string]bool)

nc.Subscribe("orders", func(msg *nats.Msg) {
    msgID := msg.Header.Get("Nats-Msg-Id")
    if processedIDs[msgID] {
        return  // 已处理
    }
    process(msg)
    processedIDs[msgID] = true
})
```

---

## 2.25.4 RabbitMQ幂等性

### 实现方式

```python
# 使用消息ID实现幂等性
processed_ids = set()

def callback(ch, method, properties, body):
    message_id = properties.message_id
    if message_id in processed_ids:
        ch.basic_ack(delivery_tag=method.delivery_tag)
        return  # 已处理

    process(body)
    processed_ids.add(message_id)
    ch.basic_ack(delivery_tag=method.delivery_tag)

# 发送消息时设置message_id
channel.basic_publish(
    exchange='orders',
    routing_key='',
    body=message,
    properties=pika.BasicProperties(
        message_id=str(uuid.uuid4()),
        delivery_mode=2
    )
)
```

---

## 2.25.5 幂等性最佳实践

### 设计建议

1. **幂等性设计**
   - 消息ID唯一性
   - 业务层幂等性
   - 状态机设计

2. **实现方式**
   - 系统原生支持（Kafka）
   - 应用层实现（NATS/RabbitMQ）
   - 数据库唯一约束

3. **性能考虑**
   - 幂等性检查开销
   - 存储优化
   - 缓存策略

---

**最后更新**: 2025-12-31
