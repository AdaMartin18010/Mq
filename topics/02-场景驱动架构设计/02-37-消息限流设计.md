# 2.37 消息限流设计

## 目录

- [2.37 消息限流设计](#237-消息限流设计)
  - [目录](#目录)
  - [2.37.1 限流场景](#2371-限流场景)
    - [常见场景](#常见场景)
  - [2.37.2 Kafka限流](#2372-kafka限流)
    - [限流实现](#限流实现)
  - [2.37.3 NATS限流](#2373-nats限流)
    - [限流实现](#限流实现-1)
  - [2.37.4 RabbitMQ限流](#2374-rabbitmq限流)
    - [限流实现](#限流实现-2)
  - [2.37.5 限流最佳实践](#2375-限流最佳实践)
    - [设计建议](#设计建议)

---

## 2.37.1 限流场景

### 常见场景

1. **流量控制**
   - 防止系统过载
   - 保护下游服务
   - 平滑流量峰值

2. **资源保护**
   - CPU保护
   - 内存保护
   - 网络带宽保护

3. **公平性保证**
   - 多租户限流
   - 优先级限流
   - 配额管理

---

## 2.37.2 Kafka限流

### 限流实现

```java
// Producer限流
Properties props = new Properties();
props.put("bootstrap.servers", "localhost:9092");
props.put("max.in.flight.requests.per.connection", 5);  // 限制并发请求
props.put("batch.size", 16384);  // 批量大小限制
props.put("linger.ms", 10);  // 延迟发送

// Consumer限流
Properties props = new Properties();
props.put("bootstrap.servers", "localhost:9092");
props.put("fetch.min.bytes", 1);  // 最小拉取字节
props.put("fetch.max.wait.ms", 500);  // 最大等待时间
props.put("max.partition.fetch.bytes", 1048576);  // 分区拉取限制

// 应用层限流
RateLimiter rateLimiter = RateLimiter.create(1000.0);  // 每秒1000条
for (int i = 0; i < messages.size(); i++) {
    rateLimiter.acquire();
    producer.send(new ProducerRecord<>("orders", messages.get(i)));
}
```

---

## 2.37.3 NATS限流

### 限流实现

```go
// 订阅限流
sub, err := nc.Subscribe("orders.*", func(msg *nats.Msg) {
    processMessage(msg)
})
if err != nil {
    log.Fatal(err)
}

// 设置限流
sub.SetPendingLimits(1000, 10*1024*1024)  // 1000条消息或10MB

// 应用层限流
rateLimiter := rate.NewLimiter(rate.Limit(1000), 100)  // 每秒1000条
for _, msg := range messages {
    if err := rateLimiter.Wait(context.Background()); err != nil {
        log.Fatal(err)
    }
    nc.Publish("orders", msg)
}
```

---

## 2.37.4 RabbitMQ限流

### 限流实现

```python
# Consumer限流
channel.basic_qos(
    prefetch_count=10,  # 每次最多处理10条消息
    prefetch_size=0,  # 不限制大小
    global_=False  # 仅对当前channel生效
)

# Producer限流
rate_limiter = RateLimiter(max_calls=1000, period=1.0)  # 每秒1000条

def publish_with_rate_limit(message):
    rate_limiter.acquire()
    channel.basic_publish(
        exchange='orders',
        routing_key='',
        body=message
    )

# 应用层限流
from ratelimit import limits, sleep_and_retry

@sleep_and_retry
@limits(calls=1000, period=1)
def publish_message(message):
    channel.basic_publish(
        exchange='orders',
        routing_key='',
        body=message
    )
```

---

## 2.37.5 限流最佳实践

### 设计建议

1. **限流策略**
   - 固定窗口限流
   - 滑动窗口限流
   - 令牌桶限流

2. **限流粒度**
   - 全局限流
   - 分区限流
   - 用户限流

3. **限流处理**
   - 拒绝策略
   - 等待策略
   - 降级策略

---

**最后更新**: 2025-12-31
