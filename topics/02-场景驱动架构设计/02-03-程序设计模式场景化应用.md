# 2.3 程序设计模式场景化应用

## 目录

- [2.3 程序设计模式场景化应用](#23-程序设计模式场景化应用)
  - [目录](#目录)
  - [2.3.1 电商订单场景：Kafka设计模式组合](#231-电商订单场景kafka设计模式组合)
  - [2.3.2 智能家居场景：MQTT设计模式组合](#232-智能家居场景mqtt设计模式组合)
  - [2.3.3 金融交易场景：NATS设计模式组合](#233-金融交易场景nats设计模式组合)
  - [2.3.4 混合场景：智能汽车数据平台](#234-混合场景智能汽车数据平台)
  - [2.3.5 场景化设计模式参考资源](#235-场景化设计模式参考资源)
    - [设计模式参考](#设计模式参考)
    - [场景案例参考](#场景案例参考)

---

## 2.3.1 电商订单场景：Kafka设计模式组合

**场景**：订单创建→支付→发货→完成，需要事件溯源、CQRS、最终一致性

**设计模式组合**：

```java
// 1. 命令模式：订单Command封装
public class OrderCommand {
    private String orderId;
    private OrderAction action; // CREATE, PAY, SHIP
    private long timestamp;

    public byte[] serialize() {
        // 序列化到Kafka
        return JSON.toJSONBytes(this);
    }
}

// 2. 事件溯源模式：订单事件流
@KafkaListener(topics = "order-events")
public void processEvent(ConsumerRecord<String, OrderEvent> record) {
    // 基于offset保证事件顺序
    long offset = record.offset();
    OrderEvent event = record.value();

    // 重放逻辑：从指定offset恢复状态
    if (offset >= recoveryPoint) {
        eventSourcingAggregate.apply(event);
    }
}

// 3. 策略模式：分区策略动态切换
public class OrderPartitioner implements Partitioner {
    @Override
    public int partition(String topic, Object key, byte[] keyBytes, ...) {
        // 大促期间：按userId%分区，保证用户行为局部性
        // 平时：轮询，保证绝对均衡
        return strategy.select(key).compute(partitionNum);
    }
}
```

**架构论证**：

- **Topic拆分**：order-events按`orderId%32`分区，保证同一订单事件有序
- **副本策略**：`replication.factor=3`，`min.insync.replicas=2`，平衡可用性与性能
- **消费模式**：订单查询服务、物流服务、分析服务分别用不同Consumer Group，实现发布订阅

## 2.3.2 智能家居场景：MQTT设计模式组合

**场景**：10万+设备，指令下发、状态上报、设备联动

**设计模式组合**：

```python
# 1. 观察者模式：设备状态订阅
class DeviceStatusObserver:
    def __init__(self, device_type):
        self.device_type = device_type

    def on_message(self, client, userdata, msg):
        # 通配符订阅: home/+/sensor/#
        if msg.topic.matches(f"home/+/sensor/{self.device_type}"):
            self.process_status(msg.payload)

# 2. 状态模式：设备会话管理
class DeviceSessionContext:
    def __init__(self):
        self.state = DisconnectedState()  # 初始状态

    def connect(self):
        self.state = self.state.on_connect()  # 转移到ConnectedState

    def disconnect(self):
        self.state = self.state.on_disconnect()  # 触发遗嘱发布

# 3. 代理模式：设备访问控制
class MQTTBrokerProxy:
    def publish(self, topic, payload, qos=1):
        # 权限校验
        if not self.auth_service.check(topic):
            raise PermissionError()
        # 速率限制
        self.rate_limiter.acquire()
        # 发布到真实Broker
        self.broker_client.publish(topic, payload, qos)
```

**架构论证**：

- **主题设计**：`home/{roomId}/device/{deviceType}/{deviceId}/cmd`四级结构，支持精确控制和批量操作
- **QoS分级**：传感器数据用QoS0（容忍丢失），门锁控制用QoS2（精确一次）
- **会话持久**：`CleanSession=0`保证设备断线重连后恢复订阅关系

## 2.3.3 金融交易场景：NATS设计模式组合

**场景**：高频交易、风控检测、实时清算，要求低延迟+高可用

**设计模式组合**：

```go
// 1. 请求-响应模式：交易RPC
func PlaceOrder(ctx context.Context, order *Order) (*Confirmation, error) {
    // 基于NATS Request-Reply
    msg, err := nc.Request("trading.order", order.Serialize(), 100*time.Millisecond)
    if err != nil {
        return nil, fmt.Errorf("timeout: %v", err)
    }
    return ParseConfirmation(msg.Data), nil
}

// 2. 事件驱动模式：风控事件流
func RiskMonitor() {
    // 订阅所有交易事件
    nc.Subscribe("trading.>", func(msg *nats.Msg) {
        // 异步风控检测，不阻塞主流程
        go func() {
            riskScore := calculateRisk(msg.Data)
            if riskScore > threshold {
                nc.Publish("risk.alert", msg.Data)
            }
        }()
    })
}

// 3. 迭代器模式：交易流水重放
js, _ := nc.JetStream()
sub, _ := js.Subscribe("trading.order", func(msg *nats.Msg) {
    // 从指定时间戳重放
    msg.Ack()
}, nats.StartTime(time.Now().Add(-24*time.Hour)))
```

**架构论证**：

- **集群部署**：3节点NATS集群，全网格连接，Gossip协议自动发现
- **持久化选择**：交易流水用JetStream持久化到SSD，实时撮合用Core NATS内存模式
- **性能保证**：NATS亚毫秒延迟，满足高频交易需求

## 2.3.4 混合场景：智能汽车数据平台

**场景**：10万辆汽车，每秒上报1000万传感器数据，需实时风控+离线分析

**架构设计**：

```yaml
# 多协议混合架构
ingestion:
  - protocol: MQTT  # 车载设备
    broker: EMQX Cluster
    topics:
      - "vehicle/{vin}/sensor/#"
    qos: 1  # 至少一次

  - protocol: NATS  # 车云实时通信
    cluster: NATS JetStream Cluster
    subjects:
      - "vehicle.alert.>"
    storage: file

  - protocol: Kafka  # 离线分析
    cluster: Kafka Cluster
    topics:
      - "vehicle-data-raw"  # 32分区
      - "vehicle-events"    # 按vin哈希

data_flow:
  mqtt → nats_bridge → nats_stream:
    purpose: 实时过滤异常数据

  mqtt → kafka_connector → kafka:
    purpose: 全量数据持久化

  nats → kafka:
    purpose: 风险事件归档
```

**关键代码**：

```go
// 桥接器实现：MQTT → NATS
func BridgeMQTTtoNATS(mqttClient MQTT.Client, natsConn *nats.Conn) {
    mqttClient.Subscribe("vehicle/+/sensor/#", 1, func(c MQTT.Client, m MQTT.Message) {
        // MQTT主题转换为NATS Subject
        natsSubject := strings.Replace(m.Topic(), "/", ".", -1)
        // QoS 1 → NATS JetStream持久化
        natsConn.Publish(natsSubject, m.Payload())
    })
}

// 风控处理器：NATS实时流
func RiskProcessor(js nats.JetStreamContext) {
    js.Subscribe("vehicle.alert.>", func(msg *nats.Msg) {
        alert := parseAlert(msg.Data)
        if alert.severity == "critical" {
            // 同步调用：请求-响应模式
            resp, _ := nc.Request("risk.action", alert.Serialize(), 100*time.Millisecond)
            executeAction(resp)
        }
        msg.Ack()
    }, nats.AckExplicit())
}
```

**论证**：

- **MQTT**：车载设备原生支持，轻量协议适合4G网络
- **NATS**：实时风控要求亚毫秒延迟，NATS Core模式满足
- **Kafka**：TB级数据需要长期存储和离线分析，Kafka生态完善
- **桥接模式**：三者通过协议桥接，发挥各自优势，避免单一MQ的妥协

## 2.3.5 场景化设计模式参考资源

### 设计模式参考

- **GoF设计模式**: [Design Patterns: Elements of Reusable Object-Oriented Software](https://en.wikipedia.org/wiki/Design_Patterns)
- **分布式系统模式**: [Patterns of Distributed Systems](https://martinfowler.com/articles/patterns-of-distributed-systems/)
- **事件驱动模式**: [Event-Driven Architecture Patterns](https://www.oreilly.com/library/view/software-architecture-patterns/9781491971437/ch02.html)

### 场景案例参考

- **电商订单场景**: [Event Sourcing Pattern](https://martinfowler.com/eaaDev/EventSourcing.html)
- **IoT场景**: [MQTT Best Practices](https://www.hivemq.com/blog/mqtt-essentials-part-5-mqtt-topics-best-practices/)
- **金融交易场景**: [High-Frequency Trading Architecture](https://www.quantstart.com/articles/high-frequency-trading-architecture/)

---

**参考来源**:

- 基于concept02.md内容整理
- GoF设计模式经典著作
- Martin Fowler的分布式系统模式
- 实际生产场景案例研究
