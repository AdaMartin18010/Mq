# 2.24 消息延迟设计

## 目录

- [2.24 消息延迟设计](#224-消息延迟设计)
  - [目录](#目录)
  - [2.24.1 延迟场景](#2241-延迟场景)
    - [常见场景](#常见场景)
  - [2.24.2 Kafka延迟消息](#2242-kafka延迟消息)
    - [实现方式](#实现方式)
    - [延迟Topic方案](#延迟topic方案)
  - [2.24.3 NATS延迟消息](#2243-nats延迟消息)
    - [实现方式](#实现方式-1)
  - [2.24.4 RabbitMQ延迟消息](#2244-rabbitmq延迟消息)
    - [延迟插件](#延迟插件)
  - [2.24.5 延迟消息最佳实践](#2245-延迟消息最佳实践)
    - [设计建议](#设计建议)

---

## 2.24.1 延迟场景

### 常见场景

1. **定时任务**
   - 延迟执行
   - 定时提醒
   - 预约处理

2. **重试策略**
   - 延迟重试
   - 指数退避
   - 固定延迟

3. **业务场景**
   - 订单超时取消
   - 支付超时处理
   - 活动开始通知

---

## 2.24.2 Kafka延迟消息

### 实现方式

```java
// 使用时间戳实现延迟
long delayTime = System.currentTimeMillis() + 60000; // 延迟1分钟
ProducerRecord<String, String> record = new ProducerRecord<>(
    "orders",
    null,
    delayTime,  // 时间戳
    key,
    value
);

// Consumer延迟消费
ConsumerRecords<String, String> records = consumer.poll(Duration.ofMillis(100));
for (ConsumerRecord<String, String> record : records) {
    if (record.timestamp() > System.currentTimeMillis()) {
        // 延迟消息，稍后处理
        continue;
    }
    process(record);
}
```

### 延迟Topic方案

```java
// 使用多个延迟Topic
String delayTopic = "orders-delay-" + delayMinutes;
producer.send(new ProducerRecord<>(delayTopic, key, value));

// 定时任务将延迟Topic消息转移到主Topic
```

---

## 2.24.3 NATS延迟消息

### 实现方式

```go
// 使用JetStream延迟消息
js.Publish("orders", data, nats.MsgId("msg-1"), nats.Delay(60*time.Second))

// 或使用应用层实现
time.AfterFunc(60*time.Second, func() {
    nc.Publish("orders", data)
})
```

---

## 2.24.4 RabbitMQ延迟消息

### 延迟插件

```python
# 安装rabbitmq-delayed-message-exchange插件
# 声明延迟Exchange
channel.exchange_declare(
    exchange='orders-delayed',
    exchange_type='x-delayed-message',
    arguments={'x-delayed-type': 'direct'}
)

# 发送延迟消息
channel.basic_publish(
    exchange='orders-delayed',
    routing_key='',
    body=message,
    properties=pika.BasicProperties(
        headers={'x-delay': 60000}  # 延迟60秒
    )
)
```

---

## 2.24.5 延迟消息最佳实践

### 设计建议

1. **延迟策略**
   - 固定延迟
   - 动态延迟
   - 延迟队列

2. **性能考虑**
   - 延迟消息存储
   - 定时扫描开销
   - 内存使用

3. **可靠性**
   - 延迟消息持久化
   - 故障恢复
   - 消息丢失防护

---

**最后更新**: 2025-12-31
