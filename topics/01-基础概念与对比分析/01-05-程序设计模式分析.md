# 1.5 程序设计模式分析

## 目录

- [1.5 程序设计模式分析](#15-程序设计模式分析)
  - [目录](#目录)
  - [1.5.1 Kafka设计模式](#151-kafka设计模式)
  - [1.5.2 MQTT设计模式](#152-mqtt设计模式)
  - [1.5.3 NATS设计模式](#153-nats设计模式)
  - [1.5.4 设计模式对比矩阵](#154-设计模式对比矩阵)
  - [1.5.5 设计模式参考资源](#155-设计模式参考资源)
    - [经典设计模式参考](#经典设计模式参考)
    - [Kafka设计模式参考](#kafka设计模式参考)
    - [MQTT设计模式参考](#mqtt设计模式参考)
    - [NATS设计模式参考](#nats设计模式参考)

---

## 1.5.1 Kafka设计模式

| 模式 | 应用 | 实现方式 |
|------|------|----------|
| **日志聚合模式** | 消息持久化 | Segment+Index文件 |
| **发布-订阅模式** | 消息分发 | Consumer Group机制 |
| **命令模式** | Producer API | 封装发送命令 |
| **观察者模式** | Consumer Rebalance | 监听分区变化 |
| **策略模式** | 分区策略 | Partitioner接口 |

**代码示例**：

```java
// 策略模式：自定义分区器
public class CustomPartitioner implements Partitioner {
    @Override
    public int partition(String topic, Object key, byte[] keyBytes,
                        Object value, byte[] valueBytes, Cluster cluster) {
        // 哈希算法决定分区
        return Math.abs(key.hashCode()) % cluster.partitionCountForTopic(topic);
    }
}
```

**架构应用**：

- **日志聚合模式**：Kafka将消息视为不可变日志，支持顺序追加和高效检索
- **发布-订阅模式**：多个Consumer Group可以独立消费同一Topic，实现消息广播
- **命令模式**：Producer API封装消息发送逻辑，支持异步和批量发送
- **观察者模式**：Consumer监听分区变化，自动触发Rebalance
- **策略模式**：支持自定义分区策略，灵活控制消息分布

## 1.5.2 MQTT设计模式

| 模式 | 应用 | 实现方式 |
|------|------|----------|
| **观察者模式** | 主题订阅 | 订阅者注册/通知 |
| **状态模式** | 会话管理 | 连接/断开/重连状态 |
| **代理模式** | Broker架构 | 客户端间解耦 |
| **工厂模式** | 消息创建 | 不同QoS消息工厂 |

**代码示例**：

```python
# 观察者模式：设备状态订阅
class DeviceObserver:
    def __init__(self, device_id):
        self.device_id = device_id
        self.client = mqtt.Client()
        self.client.on_message = self.on_message

    def subscribe(self, topic):
        self.client.subscribe(f"device/{self.device_id}/{topic}")

    def on_message(self, client, userdata, msg):
        # 处理消息通知
        self.process_notification(msg.payload)
```

**架构应用**：

- **观察者模式**：Publisher发布消息，所有订阅该Topic的Subscriber自动收到通知
- **状态模式**：MQTT连接状态机管理连接生命周期（CONNECT → CONNECTED → DISCONNECT）
- **代理模式**：Broker作为中间代理，解耦Publisher和Subscriber
- **工厂模式**：根据QoS级别创建不同类型的消息对象

## 1.5.3 NATS设计模式

| 模式 | 应用 | 实现方式 |
|------|------|----------|
| **事件驱动模式** | 异步通信 | Pub/Sub+Callbacks |
| **请求-响应模式** | RPC调用 | 临时订阅+Reply Subject |
| **迭代器模式** | 消息消费 | Consumer迭代消息 |
| **门面模式** | JetStream API | 简化流操作 |

**代码示例**：

```go
// 请求-响应模式
nc.Request("service.echo", []byte("hello"), 1*time.Second, func(msg *nats.Msg) {
    // 自动处理reply subject
    fmt.Printf("Response: %s\n", string(msg.Data))
})

// 事件驱动模式
nc.Subscribe("events.>", func(msg *nats.Msg) {
    // 异步处理事件
    go processEvent(msg.Data)
})
```

**架构应用**：

- **事件驱动模式**：基于Subject的Pub/Sub，支持异步事件处理
- **请求-响应模式**：自动生成Reply Subject，实现RPC调用
- **迭代器模式**：Consumer通过迭代器模式遍历消息流
- **门面模式**：JetStream API封装底层RAFT和存储细节

## 1.5.4 设计模式对比矩阵

| 设计模式 | Kafka | MQTT | NATS | 应用场景 |
|----------|-------|------|------|----------|
| **观察者模式** | Consumer Group | Topic订阅 | Subject订阅 | 消息通知 |
| **策略模式** | 分区策略 | QoS策略 | 路由策略 | 灵活配置 |
| **代理模式** | Broker | Broker | Server | 解耦通信 |
| **命令模式** | Producer API | PUBLISH | Publish | 封装操作 |
| **状态模式** | Partition状态 | 会话状态 | 连接状态 | 状态管理 |
| **工厂模式** | 消息工厂 | QoS工厂 | Subject工厂 | 对象创建 |
| **迭代器模式** | Consumer迭代 | 无 | Consumer迭代 | 消息遍历 |
| **门面模式** | Admin API | Broker API | JetStream API | 简化接口 |

**模式选择原则**：

1. **Kafka**：适合需要持久化和顺序性的场景，使用日志聚合和发布-订阅模式
2. **MQTT**：适合IoT设备通信，使用观察者和状态模式管理设备连接
3. **NATS**：适合微服务通信，使用事件驱动和请求-响应模式实现服务间调用

---

## 1.5.5 设计模式参考资源

### 经典设计模式参考

- **GoF设计模式**: [Design Patterns: Elements of Reusable Object-Oriented Software](https://en.wikipedia.org/wiki/Design_Patterns)
- **消息队列模式**: [Message Queue Patterns - Martin Fowler](https://martinfowler.com/articles/patterns-of-distributed-systems/)
- **事件驱动模式**: [Event-Driven Architecture Patterns](https://www.oreilly.com/library/view/software-architecture-patterns/9781491971437/ch02.html)

### Kafka设计模式参考

- **日志聚合模式**: [The Log: What every software engineer should know](https://engineering.linkedin.com/distributed-systems/log-what-every-software-engineer-should-know-about-real-time-datas-unifying)
- **发布-订阅模式**: [Kafka Consumer Groups](https://kafka.apache.org/documentation/#consumerconfigs)
- **分区策略**: [Kafka Partitioning](https://kafka.apache.org/documentation/#partitioning)

### MQTT设计模式参考

- **观察者模式**: [MQTT Pub/Sub Model](https://docs.oasis-open.org/mqtt/mqtt/v5.0/mqtt-v5.0.html#_Toc3901103)
- **状态模式**: [MQTT Session State](https://docs.oasis-open.org/mqtt/mqtt/v5.0/mqtt-v5.0.html#_Toc3901039)

### NATS设计模式参考

- **事件驱动模式**: [NATS Event-Driven Architecture](https://docs.nats.io/nats-concepts/events)
- **请求-响应模式**: [NATS Request-Reply](https://docs.nats.io/nats-concepts/nats-req-rep)

---

**参考来源**:

- 基于concept01.md内容整理
- 《设计模式：可复用面向对象软件的基础》（GoF）
- Martin Fowler的分布式系统模式
- Kafka、MQTT、NATS官方文档中的设计模式应用
